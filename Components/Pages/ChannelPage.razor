@page "/channel/{channelIdAsString}"
@rendermode InteractiveServer
@implements IDisposable
@using CactusFrontEnd.Components.Layout
@using CactusFrontEnd.Utils
@using CactusFrontEnd.Security
@using Messenger
@using MessengerInterfaces
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@inject ProtectedLocalStorage ProtectedLocalStore
@inject IJSRuntime jsRuntime
@inherits AuthorizedPage

<PageTitle>Channel</PageTitle>
<div class="chatContainer">
	<div class="chat">
		<h3>@header</h3>
		<p style="opacity: 0.5">@channelMembers</p>
		<ul>
			@foreach (var message in messages)
			{
				<li class=@(message.AuthorId == user.Id ? "selfSentMessage message" : "message")>
					@if (message.AuthorId == user.Id || user.IsAdmin)
					{
						<ContextMenuTrigger id=@message.Id.ToString() MenuId="messageContextMenu">
								<span class="authorName">@message.AuthorName</span><span class="timestamp">@Utils.Relativize(message.DateTime, DateTime.UtcNow)</span><br />
							<div class="messageContent">
								<span class="messageContent">@message.Content</span>
							</div>
						</ContextMenuTrigger>
					}
					else
					{
						<span class="authorName">@message.AuthorName</span>

						<span class="timestamp">@Utils.Relativize(message.DateTime, DateTime.UtcNow)</span>

						<br />
						<span class="messageContent">@message.Content</span>
					}
				</li>
			}
		</ul>
		<div id="messageInput">
			<input @bind-value:after=@onTextInputChange id="messageInputTextBox" autocomplete="off" type="text" @bind-value="messageContent" @onkeydown=@textBoxKeyboardEventHandler><input type="button" id="sendButton" value="Send" @onclick=@send />
		</div>
	</div>
</div>

<ContextMenu Id="messageContextMenu" Template="cactusTemplate">
	<Item OnClick=@deleteMessageClick>Delete Message</Item>
	<Item OnClick=@copyMessageIdClick>Copy Id</Item>
</ContextMenu>

@code {
	[Parameter]
	public string ChannelIdAsString { get; set; }
	[Inject]
	IMessengerService messengerService { get; set; }
	[Inject]
	NavigationManager navigationManager { get; set; }
	MessageDTO_Output[] messages = [];
	List<string> messageDisplays = [];
	ChannelDTO_Output channel;
	string header = "Loading...";
	string channelMembers = "";
	string messageContent;
	string testString = "a";
	bool enterPressed = false;
	Action<ChannelDTO_Output> onMessageAction;
	ElementReference messageInput;
	Timer refreshTimeStampTimer;

	protected async override void OnAfterRender(bool firstRender)
	{
		if (firstRender)
		{
			var startTimeSpan = TimeSpan.Zero;
			var periodTimeSpan = TimeSpan.FromMinutes(1);

			refreshTimeStampTimer = new Timer(async (a) =>
			{
				await InvokeAsync(this.StateHasChanged);
			}, null, startTimeSpan, periodTimeSpan);

			onMessageAction = async channel =>
			{
				if (channel.Users.Contains(user.Id) || channel.Id == Guid.Parse(ChannelIdAsString))
				{
					await refresh();
				}
			};
			messengerService.OnMessage += onMessageAction;

			await this.Initialize(ProtectedLocalStore, () => navigationManager.NavigateTo($"logout?redirectUrl=channel/{ChannelIdAsString}"), messengerService);
			if (this.signedToken is null)
			{
				return;
			}
			try
			{
				channel = await messengerService.GetChannel(Guid.Parse(ChannelIdAsString), user.Id);
				channelMembers = string.Join(", ", channel.UserNames);
				header = channel.Name ?? channelMembers;
				this.StateHasChanged();
			}
			catch (UnauthorizedAccessException)
			{
				navigationManager.NavigateTo("Error/Unauthorized");
				return;
			}
			catch (Exception ex)
			{
				if (ex is KeyNotFoundException || ex is FormatException)
				{
					navigationManager.NavigateTo("Error/NotFound");
				}
				else
				{
					throw;
				}
				return;
			}
			await refresh();
		}
	}

	private async Task send()
	{
		if (!string.IsNullOrWhiteSpace(messageContent))
		{
			enterPressed = false;
			Message msg = new(Guid.NewGuid(), messageContent, DateTime.UtcNow, user.Id, channel.Id);
			messageContent = "";
			await messengerService.PostMessage(msg, user.Id);
		}
	}

	private string getMessageDisplay(MessageDTO_Output msg)
	{
		return $"{msg.AuthorName}: {msg.Content} - {msg.DateTime}";
	}

	private async Task refresh()
	{
		try
		{
			messages = await messengerService.GetAllMessagesInChannel(channel.Id, user.Id);
			messages = messages.OrderByDescending(o => o.DateTime).ToArray();
			await InvokeAsync(this.StateHasChanged);
		}
		catch { }
	}

	public void Dispose()
	{
		messengerService.OnMessage -= onMessageAction;
		refreshTimeStampTimer?.Dispose();
	}

	private async Task textBoxKeyboardEventHandler(KeyboardEventArgs args)
	{
		if (args.Key == "Enter")
		{
			enterPressed = true;
			await send();
		}
	}

	private async Task onTextInputChange()
	{
		if (enterPressed)
		{
			await send();
		}
	}

	private async Task deleteMessageClick(ItemClickEventArgs e)
	{
		string messageId = e.ContextMenuTrigger.Id;
		await messengerService.DeleteMessage(Guid.Parse(messageId), user.Id);
	}

	private async void copyMessageIdClick(ItemClickEventArgs e)
	{
		await jsRuntime.InvokeVoidAsync($"navigator.clipboard.writeText", e.ContextMenuTrigger.Id);
	}
}